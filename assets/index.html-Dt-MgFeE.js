import{_ as e,c as s,b as i,o as n}from"./app-BxaswAnj.js";const t="/rui-plume/assets/3.pipeline%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA-DTstBi18.jpg",l={};function r(p,a){return n(),s("div",null,[...a[0]||(a[0]=[i('<h1 id="是什么" tabindex="-1"><a class="header-anchor" href="#是什么"><span>是什么</span></a></h1><h3 id="上述问题的解决思路" tabindex="-1"><a class="header-anchor" href="#上述问题的解决思路"><span>上述问题的解决思路</span></a></h3><p>管道(pipeline)可以一次性发送多条命令给服务端，<strong>服务端依次处理完毕后，通过一 条响应一次性将结果返回，通过减少客户端与redis的通信次数来实现降低往返延时时间</strong>。pipeline实现的原理是队列，先进先出特性就保证数据的顺序性。</p><p>![](images/2.Redis pipeline交互模型.jpg)</p><h3 id="官网" tabindex="-1"><a class="header-anchor" href="#官网"><span>官网：</span></a></h3><p>https://redis.io/docs/manual/pipelining/</p><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span>定义：</span></a></h3><p>pipeline是为了解决RTT往返时，仅仅是将命令打包一次性发送，对整个Redis的执行不造成其他任何影响</p><h3 id="一句话" tabindex="-1"><a class="header-anchor" href="#一句话"><span>一句话：</span></a></h3><p><strong>批处理命令变种优化措施</strong>，类似Redis的原生批命令(mget和mset)</p><h3 id="案例演示" tabindex="-1"><a class="header-anchor" href="#案例演示"><span>案例演示</span></a></h3><p><img src="'+t+'" alt=""></p><h3 id="小总结" tabindex="-1"><a class="header-anchor" href="#小总结"><span>小总结</span></a></h3><ul><li><p>pipeline与原生批量命令对比</p><ol><li>原生批量命令是原子性(例如：mset、mget)，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi>p</mi><mi>i</mi><mi>p</mi><mi>e</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi><mtext>是非原子性的</mtext></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{red}{pipeline是非原子性的}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="color:red;">p</span><span class="mord mathnormal" style="color:red;">i</span><span class="mord mathnormal" style="color:red;">p</span><span class="mord mathnormal" style="color:red;">e</span><span class="mord mathnormal" style="margin-right:0.01968em;color:red;">l</span><span class="mord mathnormal" style="color:red;">in</span><span class="mord mathnormal" style="color:red;">e</span><span class="mord cjk_fallback" style="color:red;">是非原子性的</span></span></span></span></li><li>原生批量命令一次只能执行一种命令，pipeline支持批量执行不同命令</li><li>原生批量命令是服务端实现，而pipeline需要服务端与客户端共同完成</li></ol></li><li><p>pipeline与事务对比</p><ol><li>事务具有原子性，管道不具有原子性</li><li>管道一次性将多条命令发送到服务器，事务是一条一条的发，事务只有在接收到exec命令后才会执行，管道不会</li><li>执行事务时会阻塞其他命令的执行，而执行管道中的命令时不会</li></ol></li><li><p>使用pipeline注意事项</p><ol><li>pipeline缓冲的指令只是会依次执行，不保证原子性，如果执行中指令发生异常，将会继续执行后续的指令</li><li>使用pipeline组装的命令个数不能太多，不然数量过大客户端阻塞的时间可能过久，同时服务端此时也被迫回复一个队列答复，占用很多内存</li></ol></li></ul>',14)])])}const m=e(l,[["render",r]]),c=JSON.parse('{"path":"/article/hlkrrln7/","title":"2.是什么","lang":"zh-CN","frontmatter":{"title":"2.是什么","createTime":"2025/08/25 22:29:40","permalink":"/article/hlkrrln7/","watermark":true},"readingTime":{"minutes":1.66,"words":498},"git":{"createdTime":1756136329000,"updatedTime":1756136329000,"contributors":[{"name":"HRF","username":"HRF","email":"3398775460@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/HRF?v=4","url":"https://github.com/HRF"}]},"filePathRelative":"study-notes/back-end/redis/6.Redis管道/2.是什么.md","headers":[],"categoryList":[{"id":"3c4c90","sort":10002,"name":"study-notes"},{"id":"fe643d","sort":10003,"name":"back-end"},{"id":"46b09b","sort":10033,"name":"redis"},{"id":"483818","sort":6,"name":"Redis管道"}]}');export{m as comp,c as data};
