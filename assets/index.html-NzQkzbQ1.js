import{_ as h,c as t,a as i,b as p,d as e,w as n,r as k,o as d,e as l}from"./app-BxaswAnj.js";const r={},g={class:"table-of-contents"};function A(o,s){const a=k("router-link");return d(),t("div",null,[i("nav",g,[i("ul",null,[i("li",null,[e(a,{to:"#_1-缓存"},{default:n(()=>[...s[0]||(s[0]=[l("1. 缓存",-1)])]),_:1})]),i("li",null,[e(a,{to:"#_2-数据共享分布式"},{default:n(()=>[...s[1]||(s[1]=[l("2. 数据共享分布式",-1)])]),_:1})]),i("li",null,[e(a,{to:"#_3、分布式锁"},{default:n(()=>[...s[2]||(s[2]=[l("3、分布式锁",-1)])]),_:1})]),i("li",null,[e(a,{to:"#_4、全局id"},{default:n(()=>[...s[3]||(s[3]=[l("4、全局ID",-1)])]),_:1})]),i("li",null,[e(a,{to:"#_5、计数器"},{default:n(()=>[...s[4]||(s[4]=[l("5、计数器",-1)])]),_:1})]),i("li",null,[e(a,{to:"#_6、限流"},{default:n(()=>[...s[5]||(s[5]=[l("6、限流",-1)])]),_:1})]),i("li",null,[e(a,{to:"#_7、位统计"},{default:n(()=>[...s[6]||(s[6]=[l("7、位统计",-1)])]),_:1})]),i("li",null,[e(a,{to:"#_8-时间轴-timeline"},{default:n(()=>[...s[7]||(s[7]=[l("8. 时间轴（Timeline）",-1)])]),_:1})]),i("li",null,[e(a,{to:"#_9-消息队列"},{default:n(()=>[...s[8]||(s[8]=[l("9. 消息队列",-1)])]),_:1})]),i("li",null,[e(a,{to:"#_10、抽奖"},{default:n(()=>[...s[9]||(s[9]=[l("10、抽奖",-1)])]),_:1})]),i("li",null,[e(a,{to:"#_11、点赞、签到、打卡"},{default:n(()=>[...s[10]||(s[10]=[l("11、点赞、签到、打卡",-1)])]),_:1})]),i("li",null,[e(a,{to:"#_12-商品标签"},{default:n(()=>[...s[11]||(s[11]=[l("12 商品标签",-1)])]),_:1})]),i("li",null,[e(a,{to:"#_13、好友关系、用户关注、推荐模型"},{default:n(()=>[...s[12]||(s[12]=[l("13、好友关系、用户关注、推荐模型",-1)])]),_:1})]),i("li",null,[e(a,{to:"#_14-排行榜"},{default:n(()=>[...s[13]||(s[13]=[l("14 .排行榜",-1)])]),_:1})]),i("li",null,[e(a,{to:"#_15-倒排索引"},{default:n(()=>[...s[14]||(s[14]=[l("15 .倒排索引",-1)])]),_:1})]),i("li",null,[e(a,{to:"#_16-显示最新的项目列表"},{default:n(()=>[...s[15]||(s[15]=[l("16 .显示最新的项目列表",-1)])]),_:1})])])]),s[16]||(s[16]=p(`<h1 id="redis-16-个常见使用场景" tabindex="-1"><a class="header-anchor" href="#redis-16-个常见使用场景"><span>Redis 16 个常见使用场景</span></a></h1><h2 id="_1-缓存" tabindex="-1"><a class="header-anchor" href="#_1-缓存"><span>1. 缓存</span></a></h2><p>DB缓存，减轻DB服务器压力 提高系统响应 作为Key-Value形态的内存数据库，Redis 最先会被想到的应用场景便是作为数据缓存。而使用 Redis 缓存数据非常简单，只需要通过string类型将序列化后的对象存起来即可，不过也有一些需要注意的地方：</p><p>必须保证不同对象的 key 不会重复，并且使 key 尽量短，一般使用类名（表名）加主键拼接而成。</p><p>选择一个优秀的序列化方式也很重要，目的是提高序列化的效率和减少内存占用。</p><p>缓存内容与数据库的一致性，这里一般有两种做法：</p><p>只在数据库查询后将对象放入缓存，如果对象发生了修改或删除操作，直接清除对应缓存（或设为过期）。 在数据库新增和查询后将对象放入缓存，修改后更新缓存，删除后清除对应缓存（或设为过期）。</p><h2 id="_2-数据共享分布式" tabindex="-1"><a class="header-anchor" href="#_2-数据共享分布式"><span>2. 数据共享分布式</span></a></h2><p>String 类型，因为 Redis 是分布式的独立服务，可以在多个应用之间共享</p><p>例如：分布式Session</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">dependency</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">groupId</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">org</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">springframework</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">session</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;/</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">groupId</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">artifactId</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">spring</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">session</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">data</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">redis</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;/</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">artifactId</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;/</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">dependency</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3、分布式锁" tabindex="-1"><a class="header-anchor" href="#_3、分布式锁"><span>3、分布式锁</span></a></h2><p>如今都是分布式的环境下java自带的单体锁已经不适用的。在 Redis 2.6.12 版本开始，string的set命令增加了一些参数：</p><p>EX：设置键的过期时间（单位为秒）</p><p>PX：设置键的过期时间（单位为毫秒）</p><p>NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</p><p>XX ：只在键已经存在时，才对键进行设置操作。</p><p>由于这个操作是原子性的，可以简单地以此实现一个分布式的锁，例如：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">set</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> lock_key</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> locked</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> NX</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> EX</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果这个操作返回false，说明 key 的添加不成功，也就是当前有人在占用这把锁。而如果返回true，则说明得了锁，便可以继续进行操作，并且在操作后通过del命令释放掉锁。并且即使程序因为某些原因并没有释放锁，由于设置了过期时间，该锁也会在 1 秒后自动释放，不会影响到其他程序的运行。</p><p>推荐使用 redisson 第三方库实现分布式锁。 参考 java分布式锁终极解决方案之 redisson</p><h2 id="_4、全局id" tabindex="-1"><a class="header-anchor" href="#_4、全局id"><span>4、全局ID</span></a></h2><p>int类型，incrby，利用原子性</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">incrby</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> userid</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1000</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>分库分表的场景，一次性拿一段</p><h2 id="_5、计数器" tabindex="-1"><a class="header-anchor" href="#_5、计数器"><span>5、计数器</span></a></h2><p>int类型，incr方法</p><p>例如：文章的阅读量、微博点赞数、允许一定的延迟，先写入Redis再定时同步到数据库</p><p>计数功能应该是最适合 Redis 的使用场景之一了，因为它高频率读写的特征可以完全发挥 Redis 作为内存数据库的高效。在 Redis 的数据结构中，string、hash和sorted set都提供了incr方法用于原子性的自增操作，下面举例说明一下它们各自的使用场景：</p><p>如果应用需要显示每天的注册用户数，便可以使用string作为计数器，设定一个名为REGISTERED_COUNT_TODAY的 key，并在初始化时给它设置一个到凌晨 0 点的过期时间，每当用户注册成功后便使用incr命令使该 key 增长 1，同时当每天凌晨 0 点后，这个计数器都会因为 key 过期使值清零。 每条微博都有点赞数、评论数、转发数和浏览数四条属性，这时用hash进行计数会更好，将该计数器的 key 设为weibo:weibo_id，hash的 field 为like_number、comment_number、forward_number和view_number，在对应操作后通过hincrby使hash 中的 field 自增。 如果应用有一个发帖排行榜的功能，便选择sorted set吧，将集合的 key 设为POST_RANK。当用户发帖后，使用zincrby将该用户 id 的 score 增长 1。sorted set会重新进行排序，用户所在排行榜的位置也就会得到实时的更新。</p><h2 id="_6、限流" tabindex="-1"><a class="header-anchor" href="#_6、限流"><span>6、限流</span></a></h2><p>int类型，incr方法</p><p>以访问者的ip和其他信息作为key，访问一次增加一次计数，超过次数则返回false</p><h2 id="_7、位统计" tabindex="-1"><a class="header-anchor" href="#_7、位统计"><span>7、位统计</span></a></h2><p>String类型的bitcount（1.6.6的bitmap数据结构介绍）</p><p>字符是以8位二进制存储的</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">set</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> k1</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> a</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">setbit</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> k1</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 6</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">setbit</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> k1</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 7</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">get</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> k1</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">/*</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 6</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 7</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 代表的a的二进制位的修改</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">a</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 对应的ASCII码是97，转换为二进制数据是01100001</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">b</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 对应的ASCII码是98，转换为二进制数据是01100010</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">因为bit非常节省空间（1</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> MB=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">8388608</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> bit），可以用来做大数据量的统计。</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">/</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参考 <a href="https://blog.csdn.net/agonie201218/article/details/107161106" target="_blank" rel="noopener noreferrer">使用Redis的bitmaps统计用户留存率、活跃用户</a></p><p><a href="https://blog.csdn.net/agonie201218/article/details/108988577" target="_blank" rel="noopener noreferrer">用户日活月活怎么统计 - Redis HyperLogLog 详解</a></p><h2 id="_8-时间轴-timeline" tabindex="-1"><a class="header-anchor" href="#_8-时间轴-timeline"><span>8. 时间轴（Timeline）</span></a></h2><p>list作为双向链表，不光可以作为队列使用。如果将它用作栈便可以成为一个公用的时间轴。当用户发完微博后，都通过lpush将它存放在一个 key 为LATEST_WEIBO的list中，之后便可以通过lrange取出当前最新的微博。</p><h2 id="_9-消息队列" tabindex="-1"><a class="header-anchor" href="#_9-消息队列"><span>9. 消息队列</span></a></h2><p>Redis 中list的数据结构实现是双向链表，所以可以非常便捷的应用于消息队列（生产者 / 消费者模型）。消息的生产者只需要通过lpush将消息放入 list，消费者便可以通过rpop取出该消息，并且可以保证消息的有序性。如果需要实现带有优先级的消息队列也可以选择sorted set。而pub/sub功能也可以用作发布者 / 订阅者模型的消息。无论使用何种方式，由于 Redis 拥有持久化功能，也不需要担心由于服务器故障导致消息丢失的情况。</p><p>List提供了两个阻塞的弹出操作：blpop/brpop，可以设置超时时间</p><p>blpop：blpop key1 timeout 移除并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 brpop：brpop key1 timeout 移除并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 上面的操作。其实就是java的阻塞队列。学习的东西越多。学习成本越低</p><p>队列：先进先除：rpush blpop，左头右尾，右边进入队列，左边出队列 栈：先进后出：rpush brpop</p><h2 id="_10、抽奖" tabindex="-1"><a class="header-anchor" href="#_10、抽奖"><span>10、抽奖</span></a></h2><p>利用set结构的无序性,通过 Spop（ Redis Spop 命令用于移除集合中的指定 key 的一个或多个随机元素，移除后会返回移除的元素。 ） 随机获得值</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">redis</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">&gt; </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">SADD</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> myset</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">one</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">integer</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> 1</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">redis</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">&gt; </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">SADD</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> myset</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">two</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">integer</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> 1</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">redis</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">&gt; </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">SADD</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> myset</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">three</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">integer</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> 1</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">redis</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">&gt; </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">SPOP</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> myset</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">&quot;one&quot;</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">redis</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">&gt; </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">SMEMBERS</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> myset</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">1</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">) </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">three</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">2</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">) </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">two</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">   redis</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">&gt; </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">SADD</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> myset</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">four</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">   (</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">integer</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> 1</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">   redis</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">&gt; </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">SADD</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> myset</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">five</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">   (</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">integer</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> 1</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">   redis</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">&gt; </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">SPOP</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> myset</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 3</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">1</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">) </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">five</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">2</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">) </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">four</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">3</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">) </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">two</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">   redis</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">&gt; </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">SMEMBERS</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> myset</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">1</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">) </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">three</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">   redis</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_11、点赞、签到、打卡" tabindex="-1"><a class="header-anchor" href="#_11、点赞、签到、打卡"><span>11、点赞、签到、打卡</span></a></h2><p>假如上面的微博ID是t1001，用户ID是u3001</p><p>用 like:t1001 来维护 t1001 这条微博的所有点赞用户</p><ol><li>点赞了这条微博：sadd like:t1001 u3001</li><li>取消点赞：srem like:t1001 u3001</li><li>是否点赞：sismember like:t1001 u3001</li><li>点赞的所有用户：smembers like:t1001</li><li>点赞数：scard like:t1001 是不是比数据库简单多了。</li></ol><h2 id="_12-商品标签" tabindex="-1"><a class="header-anchor" href="#_12-商品标签"><span>12 商品标签</span></a></h2><p>老规矩，用 tags:i5001 来维护商品所有的标签。</p><ol><li>sadd tags:i5001 画面清晰细腻</li><li>sadd tags:i5001 真彩清晰显示屏</li><li>sadd tags:i5001 流程至极</li></ol><h2 id="_13、好友关系、用户关注、推荐模型" tabindex="-1"><a class="header-anchor" href="#_13、好友关系、用户关注、推荐模型"><span>13、好友关系、用户关注、推荐模型</span></a></h2><p>这个场景最开始是是一篇介绍微博 Redis 应用的 PPT 中看到的，其中提到微博的 Redis 主要是用在在计数和好友关系两方面上，当时对好友关系方面的用法不太了解，后来看到《Redis 设计与实现》中介绍到作者最开始去使用 Redis 便是希望能通过set解决传统数据库无法快速计算集合中交集这个功能。后来联想到微博当前的业务场景，确实能够以这种方式实现，所以姑且猜测一下：</p><p>对于一个用户 A，将它的关注和粉丝的用户 id 都存放在两个 set 中：</p><ol><li>A:follow：存放 A 所有关注的用户 id</li><li>A:follower：存放 A 所有粉丝的用户 id</li></ol><p>那么通过sinter命令便可以根据A:follow和A:follower的交集得到与 A 互相关注的用户。当 A 进入另一个用户 B 的主页后，A:follow和B:follow的交集便是 A 和 B 的共同专注，A:follow和B: follower的交集便是 A 关注的人也关注了 B。</p><p>举例 follow 关注 fans 粉丝</p><p>相互关注：</p><ol><li><p>sadd 1:follow 2</p></li><li><p>sadd 2:fans 1</p></li><li><p>sadd 1:fans 2</p></li><li><p>sadd 2:follow 1 我关注的人也关注了他(取交集)：</p></li><li><p>sinter 1:follow 2:fans 可能认识的人：</p></li><li><p>用户1可能认识的人(差集)：sdiff 2:follow 1:follow</p></li><li><p>用户2可能认识的人：sdiff 1:follow 2:follow</p></li></ol><h2 id="_14-排行榜" tabindex="-1"><a class="header-anchor" href="#_14-排行榜"><span>14 .排行榜</span></a></h2><p>使用sorted set(有序set) 和一个计算热度的算法便可以轻松打造一个热度排行榜，zrevrangebyscore可以得到以分数倒序排列的序列，zrank可以得到一个成员在该排行榜的位置（是分数正序排列时的位置，如果要获取倒序排列时的位置需要用zcard-zrank）。</p><p>id 为6001 的新闻点击数加1：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">zincrby</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> hotNews:20190926</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> n6001</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>获取今天点击最多的15条：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">zrevrange</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> hotNews:20190926</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 15</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> withscores</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="_15-倒排索引" tabindex="-1"><a class="header-anchor" href="#_15-倒排索引"><span>15 .倒排索引</span></a></h2><p>倒排索引是构造搜索功能的最常见方式，在 Redis 中也可以通过set进行建立倒排索引，这里以简单的拼音 + 前缀搜索城市功能举例：</p><p>假设一个城市北京，通过拼音词库将北京转为beijing，再通过前缀分词将这两个词分为若干个前缀索引，有：北、北京、b、be…beijin和beijing。将这些索引分别作为set的 key（例如:index:北）并存储北京的 id，倒排索引便建立好了。接下来只需要在搜索时通过关键词取出对应的set并得到其中的 id 即可。</p><h2 id="_16-显示最新的项目列表" tabindex="-1"><a class="header-anchor" href="#_16-显示最新的项目列表"><span>16 .显示最新的项目列表</span></a></h2><p>比如说，我们的一个Web应用想要列出用户贴出的最新20条评论。在最新的评论边上我们有一个“显示全部”的链接，点击后就可以获得更多的评论。</p><p>每次新评论发表时，我们会将它的ID添加到一个Redis列表。可以限定列表的长度为5000</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">LPUSH</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> latest.comments</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在Redis中我们的最新ID使用了常驻缓存，这是一直更新的。但是我们做了限制不能超过5000个ID，因此我们的获取ID函数会一直询问Redis。只有在超出了这个范围的时候，才需要去访问数据库。</p><ul><li><a href="https://blog.csdn.net/agonie201218/article/details/123640871" target="_blank" rel="noopener noreferrer">原文链接</a></li></ul>`,79))])}const u=h(r,[["render",A]]),c=JSON.parse('{"path":"/article/50dsda7k/","title":"Redis16个常见使用场景","lang":"zh-CN","frontmatter":{"title":"Redis16个常见使用场景","tags":["redis","数据库"],"createTime":"2025/08/25 23:47:02","permalink":"/article/50dsda7k/","watermark":true},"readingTime":{"minutes":9.5,"words":2850},"git":{"createdTime":1756136329000,"updatedTime":1756136843000,"contributors":[{"name":"HRF","username":"HRF","email":"3398775460@qq.com","commits":2,"avatar":"https://avatars.githubusercontent.com/HRF?v=4","url":"https://github.com/HRF"}]},"filePathRelative":"blog-article/database/redis/redis-16-common-usage-scenarios.md","headers":[],"categoryList":[{"id":"3915c9","sort":10008,"name":"blog-article"},{"id":"97ffdb","sort":10015,"name":"database"},{"id":"8fc83c","sort":10033,"name":"redis"}]}');export{u as comp,c as data};
