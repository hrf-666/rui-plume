import{_ as n,c as r,b as t,a as l,e as a,d as m,w as p,r as o,o as i}from"./app-BxaswAnj.js";const c="/rui-plume/assets/1.10%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-caCqjUBg.png",d="/rui-plume/assets/2.10%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9B%BE%E7%A4%BA-DEc44fUy.png",h="/rui-plume/assets/3.redis%E4%BD%8D%E5%9B%BE-DugT2PfM.jpg",x={};function g(y,s){const e=o("font");return i(),r("div",null,[s[3]||(s[3]=t('<h1 id="_10大数据类型" tabindex="-1"><a class="header-anchor" href="#_10大数据类型"><span>10大数据类型</span></a></h1><p>which 10</p><p>官网:https://redis.io/docs/data-types/</p><p><img src="'+c+'" alt=""></p><p><img src="'+d+'" alt=""></p><p><strong>提前声明</strong></p><p>这里说的数据类型是value的数据类型，key的类型都是字符串</p><h2 id="_1-redis字符串-string" tabindex="-1"><a class="header-anchor" href="#_1-redis字符串-string"><span>1.redis字符串（String）</span></a></h2><p>String是redis最基本的数据类型，一个key对应一个value。</p>',9)),l("p",null,[s[1]||(s[1]=a("string类型是",-1)),m(e,{color:"red"},{default:p(()=>[...s[0]||(s[0]=[a("二进制安全的",-1)])]),_:1}),s[2]||(s[2]=a("，意思是redis的string可以包含任何数据，比如jpg图片或者序列化的对象。",-1))]),s[4]||(s[4]=t('<p>string类型是Redis最基本的数据类型，一个redis中字符串value<strong>最多可以是512M</strong></p><h2 id="_2-redis列表-list" tabindex="-1"><a class="header-anchor" href="#_2-redis列表-list"><span>2.redis列表（List）</span></a></h2><p>Redis列表是最简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="blue"><mtext>头部（左边）或者尾部（右边）</mtext></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{blue}{头部（左边）或者尾部（右边）}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:blue;">头部（左边）或者尾部（右边）</span></span></span></span>，它的底层实际是个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>双端链表</mtext></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{red}{双端链表}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">双端链表</span></span></span></span>，最多可以包含2^32-1个元素（4294967295，每个列表超过40亿个元素）</p><h2 id="_3-redis哈希表-hash" tabindex="-1"><a class="header-anchor" href="#_3-redis哈希表-hash"><span>3.redis哈希表（Hash）</span></a></h2><p>Redis Hash是一个string类型的field（字段）和value（值）的映射表，Hash特别适合用户存储对象。</p><p>Redis中每个Hash可以存储2^32-1个键值对（40多亿）</p><h2 id="_4-redis集合-set" tabindex="-1"><a class="header-anchor" href="#_4-redis集合-set"><span>4.redis集合（Set）</span></a></h2><p>Redis的Set是string类型的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>无序集合</mtext></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{red}{无序集合}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">无序集合</span></span></span></span>。集合成员是唯一的，这就意味着集合中不能出现重复的数据，集合对象的编码可以是intset或者Hashtable。</p><p>Redis中Set集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><p>集合中最大的成员数为2^32-1（4294967295，每个集合可存储40多亿个成员）</p><h2 id="_5-redis有序集合-zset" tabindex="-1"><a class="header-anchor" href="#_5-redis有序集合-zset"><span>5.redis有序集合（ZSet）</span></a></h2><p>zset(sorted set：有序集合)</p><p>Redis zset和Set一样也是string类型元素的集合，且不允许重复的成员。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>不同的是每个元素都会关联一个</mtext><mi>d</mi><mi>o</mi><mi>u</mi><mi>b</mi><mi>l</mi><mi>e</mi><mtext>类型的分数</mtext></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{red}{不同的是每个元素都会关联一个double类型的分数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord cjk_fallback" style="color:red;">不同的是每个元素都会关联一个</span><span class="mord mathnormal" style="color:red;">d</span><span class="mord mathnormal" style="color:red;">o</span><span class="mord mathnormal" style="color:red;">u</span><span class="mord mathnormal" style="color:red;">b</span><span class="mord mathnormal" style="margin-right:0.01968em;color:red;">l</span><span class="mord mathnormal" style="color:red;">e</span><span class="mord cjk_fallback" style="color:red;">类型的分数</span></span></span></span>，redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi>z</mi><mi>s</mi><mi>e</mi><mi>t</mi><mtext>的成员是唯一的，但是分数（</mtext><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi><mtext>）却可以重复。</mtext></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{red}{zset的成员是唯一的，但是分数（score）却可以重复。}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="color:red;">zse</span><span class="mord mathnormal" style="color:red;">t</span><span class="mord cjk_fallback" style="color:red;">的成员是唯一的，但是分数（</span><span class="mord mathnormal" style="color:red;">score</span><span class="mord cjk_fallback" style="color:red;">）却可以重复。</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi>z</mi><mi>s</mi><mi>e</mi><mi>t</mi><mtext>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是</mtext><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mtext>。集合中最大的成员数是</mtext><msup><mn>2</mn><mi mathvariant="normal">.</mi></msup><mn>32</mn><mo>−</mo><mn>1</mn></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{red}{zset集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。集合中最大的成员数是2^.32-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="color:red;">zse</span><span class="mord mathnormal" style="color:red;">t</span><span class="mord cjk_fallback" style="color:red;">集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">O</span><span class="mopen" style="color:red;">(</span><span class="mord" style="color:red;">1</span><span class="mclose" style="color:red;">)</span><span class="mord cjk_fallback" style="color:red;">。集合中最大的成员数是</span><span class="mord" style="color:red;"><span class="mord" style="color:red;">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.4369em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight" style="color:red;"><span class="mord mtight" style="color:red;">.</span></span></span></span></span></span></span></span><span class="mord" style="color:red;">32</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin" style="color:red;">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord" style="color:red;">1</span></span></span></span></p><h2 id="_6-redis地理空间-geo" tabindex="-1"><a class="header-anchor" href="#_6-redis地理空间-geo"><span>6.redis地理空间（GEO）</span></a></h2><p>Redis GEO主要用于存储地理位置信息，并对存储的信息进行操作，包括：</p><p>添加地理位置的坐标。</p><p>获取地理位置的坐标。</p><p>计算两个位置之间的距离。</p><p>根据用户给定的经纬度坐标来获取指定范围内的地址位置集合。</p><h2 id="_7-redis基数统计-hyperloglog" tabindex="-1"><a class="header-anchor" href="#_7-redis基数统计-hyperloglog"><span>7.redis基数统计（HyperLogLog）</span></a></h2><p>HyperLogLog是用来做<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>基数统计</mtext></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{red}{基数统计}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">基数统计</span></span></span></span>的算法，HyperLogLog的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需要的空间总是固定且是很小的。</p><p>在Redis里面，每个HyperLogLog键只需要花费12KB内存，就可以计算接近2^64个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为HyperLogLog只会根据输入元素来计算基数，而不会存储输入元素本身，所以HyperLogLog不能像集合那样，返回输入的各个元素。</p><h2 id="_8-redis位图-bitmap" tabindex="-1"><a class="header-anchor" href="#_8-redis位图-bitmap"><span>8.redis位图（bitmap）</span></a></h2><p><img src="'+h+'" alt=""></p><p>由0和1状态表现的二进制位的bit数组</p><h2 id="_9-redis位域-bitfield" tabindex="-1"><a class="header-anchor" href="#_9-redis位域-bitfield"><span>9.redis位域（bitfield）</span></a></h2><p>通过bitfield命令可以一次性操作多个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>比特位域</mtext><mo stretchy="false">(</mo><mtext>指的是连续的多个比特位</mtext><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{red}{比特位域(指的是连续的多个比特位)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback" style="color:red;">比特位域</span><span class="mopen" style="color:red;">(</span><span class="mord cjk_fallback" style="color:red;">指的是连续的多个比特位</span><span class="mclose" style="color:red;">)</span></span></span></span>，它会执行一系列操作并返回一个响应数组，这个数组中的元素对应参数列表中的相应的执行结果。</p><p>说白了就是通过bitfield命令我们可以一次性对多个比特位域进行操作。</p><h2 id="_10-redis流-stream" tabindex="-1"><a class="header-anchor" href="#_10-redis流-stream"><span>10.redis流（Stream）</span></a></h2><p>Redis Stream是Redis5.0版本新增加的数据结构。</p><p>Redis Stream主要用于消息队列（MQ，Message Queue），Redis本身就是一个Redis发布订阅（pub/sub）来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis宕机等，消息就会被丢弃。</p><p>简单来说发布订阅（pub/sub）可以分发消息，但无法记录历史消息。</p><p>而Redis Stream提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi>r</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>s</mi><mtext>常见数据类型操作命令</mtext></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{red}{redis常见数据类型操作命令}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="color:red;">re</span><span class="mord mathnormal" style="color:red;">d</span><span class="mord mathnormal" style="color:red;">i</span><span class="mord mathnormal" style="color:red;">s</span><span class="mord cjk_fallback" style="color:red;">常见数据类型操作命令</span></span></span></span></p><p>官网英文： https://redis.io/commands/</p><p>中文：http://www.redis.cn/commands.html</p>',40))])}const w=n(x,[["render",g]]),u=JSON.parse('{"path":"/article/grdwms7b/","title":"1.10大数据类型","lang":"zh-CN","frontmatter":{"title":"1.10大数据类型","createTime":"2025/08/25 22:29:42","permalink":"/article/grdwms7b/","watermark":true},"readingTime":{"minutes":3.83,"words":1149},"git":{"createdTime":1756136329000,"updatedTime":1756136329000,"contributors":[{"name":"HRF","username":"HRF","email":"3398775460@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/HRF?v=4","url":"https://github.com/HRF"}]},"filePathRelative":"study-notes/back-end/redis/3.redis10大数据类型/1.10大数据类型.md","headers":[],"categoryList":[{"id":"3c4c90","sort":10002,"name":"study-notes"},{"id":"fe643d","sort":10003,"name":"back-end"},{"id":"46b09b","sort":10033,"name":"redis"},{"id":"b49e1a","sort":3,"name":"redis10大数据类型"}]}');export{w as comp,u as data};
