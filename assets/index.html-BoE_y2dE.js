import{_ as e}from"./16.Redis集群不保证强一致性-XmaO9Pfl.js";import{_ as t,c as l,b as n,o as i}from"./app-BxaswAnj.js";const m="/rui-plume/assets/6.%E5%93%88%E5%B8%8C%E5%8F%96%E4%BD%99%E5%88%86%E5%8C%BA-BoHuzH3I.jpg",r="/rui-plume/assets/7.Hash%E7%8E%AF-C_XGwKBu.jpg",o="/rui-plume/assets/8.%E5%AF%B9%E8%8A%82%E7%82%B9%E5%8F%96Hash%E5%80%BC-BaFabj76.jpg",p="/rui-plume/assets/9.key%E7%9A%84%E8%90%BD%E9%94%AE%E8%A7%84%E5%88%99-D-efMbJG.jpg",c="/rui-plume/assets/10.%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%AE%B9%E9%94%99%E6%80%A7-DBkJYcL7.jpg",h="/rui-plume/assets/11.%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E6%89%A9%E5%B1%95%E6%80%A7-B_TIvRdk.jpg",g="/rui-plume/assets/12.%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%BC%BA%E7%82%B9-CJKqvih5.jpg",z="/rui-plume/assets/13.%E5%93%88%E5%B8%8C%E6%A7%BD-CqPidk9A.jpg",a="/rui-plume/assets/14.hash%E6%A7%BD%E8%AE%A1%E7%AE%97-CFfOx_Eg.jpg",d="/rui-plume/assets/15.Redis%E9%9B%86%E7%BE%A4%E6%9C%80%E5%A4%A7%E6%A7%BD%E4%BD%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF16384-BdjGNs6W.jpg",y={};function x(u,s){return i(),l("div",null,[...s[0]||(s[0]=[n('<h1 id="_3-slot槽位映射方案" tabindex="-1"><a class="header-anchor" href="#_3-slot槽位映射方案"><span>3.slot槽位映射方案</span></a></h1><h3 id="slot槽位映射-一般业界有三种解决方案" tabindex="-1"><a class="header-anchor" href="#slot槽位映射-一般业界有三种解决方案"><span>slot槽位映射，一般业界有三种解决方案</span></a></h3><ol><li><p>哈希取余分区(小厂)</p><p><img src="'+m+'" alt="6.哈希取余分区.jpg"></p><p>2亿条记录就是2亿个k,v，我们单机不行必须要分布式多机，假设有3台机器构成一个集群，用户每次读写操作都是根据公式：hash(key) % N个机器台数，计算出哈希值，用来决定数据映射到哪一个节点上。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="blue"><mstyle mathsize="1.2em"><mtext>优点</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{blue}{\\large 优点}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.82em;"></span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:blue;">优点</span></span></span></span>：简单粗暴，直接有效，只需要预估好数据规划好节点，例如3台、8台、10台，就能保证一段时间的数据 支撑。使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求 (并维护这些请求的信息)， 起到负载均衡+分而治之的作用。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="blue"><mstyle mathsize="1.2em"><mtext>缺点</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{blue}{\\large 缺点}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.82em;"></span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:blue;">缺点</span></span></span></span>：原来规划好的节点，进行扩容或者缩容就比较麻烦了额，不管扩缩，每次数据变动导致节点有变动，映射关系需要重新进行计算，在服务器个数固定不变时没有问题，如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化: Hash(key)/3会 变成Hash(key) /?。此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。 某个redis机器宕机了，由于台数数量变化，会导致hash取余全部数据重新洗牌。</p></li><li><p>一致性哈希算法分区(中厂)</p><ul><li><p>是什么？</p><p>一致性Hash算法背景是在1997年由麻省理工学院提出的，设计目标是<strong>为了解决分布式缓存数据变动和映射问题</strong>，某个机器宕机了，分母数量改变了，自然取余数不行了</p></li><li><p>能干嘛？</p><p>提出一致性Hash解决方案。目的是当服务器个数发生变动时，尽量减少影响客户端到服务器的映射关系</p></li><li><p>3大步骤</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="blue"><mstyle mathsize="1.2em"><mtext>算法构建一致性哈希环</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{blue}{\\large 算法构建一致性哈希环}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.82em;"></span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:blue;">算法构建一致性哈希环</span></span></span></span></p><p>一致性哈希算法必然有个hash函数并按照算法产生hash值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个hash空间[0,2^32-1]，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它首尾相连(O= 2^32),这样让它逻辑上形成了一个环形空间。 它也是按照使用取模的方法，<strong>前面笔记介绍的节点取模法是对节点（服务器）的数量进行取模。而一致性Hash算法是对2<sup>32取模，简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环**，如假设某哈希函数H的值空间为0-2</sup>32-1(即哈希值是一个32位无符号整形），整个哈希环如下图:整个空间</strong>按顺时针方向组织**，圆环的正上方的点代表0，O点右侧的第一个点代表1，以此类推，2、3、4、……直到2<sup>32-1，也就是说0点左侧的第一个点代表2</sup>32-1，0和2个32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。</p><p><img src="'+r+'" alt=""></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="blue"><mstyle mathsize="1.2em"><mtext>服务器</mtext><mi>I</mi><mi>P</mi><mtext>节点映射</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{blue}{\\large 服务器IP节点映射}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.82em;"></span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:blue;">服务器</span><span class="mord mathnormal sizing reset-size6 size7" style="margin-right:0.07847em;color:blue;">I</span><span class="mord mathnormal sizing reset-size6 size7" style="margin-right:0.13889em;color:blue;">P</span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:blue;">节点映射</span></span></span></span></p><p>将集群中各个IP节点映射到环上的某一个位置。 将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。假如4个节点NodeA、B、C、D，经过IP地址的<strong>哈希函数</strong>计算(hash(ip))，使用IP地址哈希后在环空间的位置如下:</p><p><img src="'+o+'" alt=""></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="blue"><mstyle mathsize="1.2em"><mi>k</mi><mi>e</mi><mi>y</mi><mtext>落到服务器的落键规则</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{blue}{\\large key落到服务器的落键规则}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0667em;vertical-align:-0.2333em;"></span><span class="mord mathnormal sizing reset-size6 size7" style="margin-right:0.03148em;color:blue;">k</span><span class="mord mathnormal sizing reset-size6 size7" style="margin-right:0.03588em;color:blue;">ey</span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:blue;">落到服务器的落键规则</span></span></span></span></p><p>当我们需要存储一个kv键值对时，首先计算key的hash值，hash(key)，将这个key使用相同的函数Hash计算出哈希值并确定此数据在环上的位置，<strong>从此位置沿环顺时针“行走”</strong>，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。 如我们有Object A、 Object B、 Object C. object D四个数据对象，经过哈希计算后，在环空间上的位置如下:根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。</p><p><img src="'+p+'" alt=""></p></li><li><p>优点</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="green"><mstyle mathsize="1.2em"><mtext>一致性哈希算法的容错性</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{green}{\\large 一致性哈希算法的容错性}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.82em;"></span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:green;">一致性哈希算法的容错性</span></span></span></span> ：假设Node C宕机，可以看到此时对象A、B、D不会受到影响。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务悉**〈即沿着逆时针方向行走遇到的第一台服务器）之间数据**，其它不会受到影响。简单说，就是C挂了，受到影响的只是B、C之间的数据<strong>且这些数据会转移到D进行存储</strong>。</p><p><img src="'+c+'" alt=""></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="green"><mstyle mathsize="1.2em"><mtext>一致性哈希算法的扩展性</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{green}{\\large 一致性哈希算法的扩展性}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.82em;"></span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:green;">一致性哈希算法的扩展性</span></span></span></span></p><p>数据量增加了，需要增加一台节点NodeX，X的位置在A和B之间，那收到影响的也就是A到X之间的数据，重新把A到X的数据录入到X上即可，不会导致hash取余全部数据重新洗牌。</p><p><img src="'+h+'" alt=""></p></li><li><p>缺点</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="green"><mstyle mathsize="1.2em"><mtext>一致性哈希算法的数据倾斜问题</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{green}{\\large 一致性哈希算法的数据倾斜问题}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.82em;"></span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:green;">一致性哈希算法的数据倾斜问题</span></span></span></span></p><p>一致性Hash算法在服务<strong>节点太少时</strong>，容易因为节点分布不均匀而造成<strong>数据倾斜</strong>（被缓存的对象大部分集中缓存在某一台服务器上)问题，例如系统中只有两台服务器:</p><p><img src="'+g+'" alt=""></p></li><li><p>小总结</p><p>为了在节点数目发生改变时尽可能少的迁移数据</p><p>将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash后会顺时针找到临近的存储节点存放。而当有节点加入或退出时仅影响该节点在Hash环上顺时针相邻的后续节点。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="green"><mstyle mathsize="1.2em"><mtext>优点</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{green}{\\large 优点}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.82em;"></span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:green;">优点</span></span></span></span> ：加入和删除节点只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="green"><mstyle mathsize="1.2em"><mtext>缺点</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{green}{\\large 缺点}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.82em;"></span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:green;">缺点</span></span></span></span> ：数据的分布和节点的位置有关，因为这些节点不是均匀的分布在哈希环上的，所以数据在进行存储时达不到均匀分布的效果。</p></li></ul></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mstyle mathsize="1.2em"><mtext>哈希槽分区</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{red}{\\large 哈希槽分区}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.82em;"></span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:red;">哈希槽分区</span></span></span></span>(大厂)</p><ul><li><p>是什么？ HASH_SLOT = CRC16(key) mod 16384</p><ol><li><p>为什么出现</p><p>哈希槽实质就是一个数组，数组[0, 2^14 - 1]形成hash slot空间</p></li><li><p>能干什么</p><p>解决均匀分配的问题，在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mstyle mathsize="1.2em"><mtext>数据和节点之间又加入了一层，把这层称为哈希槽</mtext><mo stretchy="false">(</mo><mi>s</mi><mi>l</mi><mi>o</mi><mi>t</mi><mo stretchy="false">)</mo><mtext>，用于管理数据和节点之间的关系</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{red}{\\large 数据和节点之间又加入了一层，把这层称为哈希槽(slot)，用于管理数据和节点之间的关系}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.3em;"></span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:red;">数据和节点之间又加入了一层，把这层称为哈希槽</span><span class="mopen sizing reset-size6 size7" style="color:red;">(</span><span class="mord mathnormal sizing reset-size6 size7" style="color:red;">s</span><span class="mord mathnormal sizing reset-size6 size7" style="margin-right:0.01968em;color:red;">l</span><span class="mord mathnormal sizing reset-size6 size7" style="color:red;">o</span><span class="mord mathnormal sizing reset-size6 size7" style="color:red;">t</span><span class="mclose sizing reset-size6 size7" style="color:red;">)</span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:red;">，用于管理数据和节点之间的关系</span></span></span></span>，现在就相当于节点上放的是槽，槽里面放的是数据。<img src="'+z+'" alt=""></p><p>槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。哈希解决的是映射问题，使用key的哈希值来计算所在的槽，便于数据分配</p></li><li><p>多少个hash</p><p>一个集群只能有16384个槽，编号0-16383(0-2^14-1)。这些槽会分配给集群中的所有主节点，分配策略没有要求。</p><p>集群会记录节点和槽的对应关系，解决了节点和槽的关系后，接下来就需要对key求哈希值，然后对16384取模，余数是几key就落入对应的槽里。HASH_SLOT = CRC16(key) mod 16384。以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。</p></li></ol></li><li><p>哈希槽计算</p><p>Redis集群中内置了16384个哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。当需要在Redis集群中放置一个key-valuel时，redis先对key使用crc16算法算出一个结果然后用结果对16384求余数[ CRC16(key) % 16384]，这样每个key都会对应一个编号在0-16383之间的哈希槽，也就是映射到某个节点上。如下代码，key之A、B在Node2， key之C落在Node3上</p><p><img src="'+a+'" alt=""></p></li></ul><h3 id="" tabindex="-1"><a class="header-anchor" href="#"><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mstyle mathsize="1.2em"><mtext>经典面试题：为什么</mtext><mi>R</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>s</mi><mtext>集群的最大槽数是</mtext><mn>16384</mn><mtext>个？</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{red}{\\large 经典面试题：为什么Redis集群的最大槽数是16384个？}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;"></span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:red;">经典面试题：为什么</span><span class="mord mathnormal sizing reset-size6 size7" style="margin-right:0.00773em;color:red;">R</span><span class="mord mathnormal sizing reset-size6 size7" style="color:red;">e</span><span class="mord mathnormal sizing reset-size6 size7" style="color:red;">d</span><span class="mord mathnormal sizing reset-size6 size7" style="color:red;">i</span><span class="mord mathnormal sizing reset-size6 size7" style="color:red;">s</span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:red;">集群的最大槽数是</span><span class="mord sizing reset-size6 size7" style="color:red;">16384</span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:red;">个？</span></span></span></span></span></a></h3><p>Redis集群并没有使用一致性hash而是引入了哈希槽的概念。Redis 集群有16384个哈希糟，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。但为什么哈希槽的数量是16384 (2^14）个呢？</p><p>CRC16算法产生的hash值有16bit，该算法可以产生2^16=65536个值。 换句话说值是分布在0～65535之间，有更大的65536不用为什么只用16384就够?</p><p>作者在做mod运算的时候，为什么不mod65536，而选择mod16384? <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="blue"><mstyle mathsize="1.2em"><mi>H</mi><mi>A</mi><mi>S</mi><mi>H</mi><mi mathvariant="normal">_</mi><mi>S</mi><mi>L</mi><mi>O</mi><mi>T</mi><mo>=</mo><mi>C</mi><mi>R</mi><mi>C</mi><mn>16</mn><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>65536</mn><mtext>为什么没启用？</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{blue}{\\large HASH\\_SLOT = CRC16(key) mod 65536为什么没启用？}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.192em;vertical-align:-0.372em;"></span><span class="mord mathnormal sizing reset-size6 size7" style="margin-right:0.08125em;color:blue;">H</span><span class="mord mathnormal sizing reset-size6 size7" style="color:blue;">A</span><span class="mord mathnormal sizing reset-size6 size7" style="margin-right:0.05764em;color:blue;">S</span><span class="mord mathnormal sizing reset-size6 size7" style="margin-right:0.08125em;color:blue;">H</span><span class="mord sizing reset-size6 size7" style="margin-right:0.02778em;color:blue;">_</span><span class="mord mathnormal sizing reset-size6 size7" style="margin-right:0.05764em;color:blue;">S</span><span class="mord mathnormal sizing reset-size6 size7" style="color:blue;">L</span><span class="mord mathnormal sizing reset-size6 size7" style="margin-right:0.13889em;color:blue;">OT</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel sizing reset-size6 size7" style="color:blue;">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.3em;"></span><span class="mord mathnormal sizing reset-size6 size7" style="margin-right:0.07153em;color:blue;">CRC</span><span class="mord sizing reset-size6 size7" style="color:blue;">16</span><span class="mopen sizing reset-size6 size7" style="color:blue;">(</span><span class="mord mathnormal sizing reset-size6 size7" style="margin-right:0.03148em;color:blue;">k</span><span class="mord mathnormal sizing reset-size6 size7" style="margin-right:0.03588em;color:blue;">ey</span><span class="mclose sizing reset-size6 size7" style="color:blue;">)</span><span class="mord mathnormal sizing reset-size6 size7" style="color:blue;">m</span><span class="mord mathnormal sizing reset-size6 size7" style="color:blue;">o</span><span class="mord mathnormal sizing reset-size6 size7" style="color:blue;">d</span><span class="mord sizing reset-size6 size7" style="color:blue;">65536</span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:blue;">为什么没启用？</span></span></span></span></p><p>作者回答：https://github.com/redis/redis/issues/2576</p><p><img src="'+d+'" alt=""></p><p>说明1：</p><p>正常的心跳数据包带有节点的完整配置，可以用幂等方式用旧的节点替换旧节点，以便更新旧的配置。 这意味着它们包含原始节点的插槽配置，该节点使用2k的空间和16k的插槽，但是会使用8k的空间（使用65k的插槽）。同时，由于其他设计折衷，Redis集群不太可能扩展到1000个以上的主节点。 因此16k处于正确的范围内，以确保每个主机具有足够的插槽，最多可容纳1000个矩阵，但数量足够少，可以轻松地将插槽配置作为原始位图传播。请注意，在小型群集中，位图将难以压缩，因为当N较小时，位图将设置的slot / N位占设置位的很大百分比。</p><p>说明2：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="blue"><mstyle mathsize="1.2em"><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mtext>如果槽位为</mtext><mn>65536</mn><mtext>，发送心跳信息的消息头达</mtext><mn>8</mn><mi>k</mi><mtext>，发送的心跳包过于庞大。</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{blue}{\\large (1)如果槽位为65536，发送心跳信息的消息头达8k，发送的心跳包过于庞大。}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.3em;"></span><span class="mopen sizing reset-size6 size7" style="color:blue;">(</span><span class="mord sizing reset-size6 size7" style="color:blue;">1</span><span class="mclose sizing reset-size6 size7" style="color:blue;">)</span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:blue;">如果槽位为</span><span class="mord sizing reset-size6 size7" style="color:blue;">65536</span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:blue;">，发送心跳信息的消息头达</span><span class="mord sizing reset-size6 size7" style="color:blue;">8</span><span class="mord mathnormal sizing reset-size6 size7" style="margin-right:0.03148em;color:blue;">k</span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:blue;">，发送的心跳包过于庞大。</span></span></span></span> 在消息头中最占空间的是myslots[CLUSTER_SLOTS/8]。当槽位为65536时，这块的大小是:65536÷8÷1024=8kb</p><p>在消息头中最占空间的是myslots[CLUSTER_SLOTS/8]。当槽位为16384时，这块的大小是:16384∶8∶1024=2kb</p><p>因为每秒钟，redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为65536，这个ping消息的消息头太大了，浪费带宽。 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="blue"><mstyle mathsize="1.2em"><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mi>r</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>s</mi><mtext>的集群主节点数量基本不可能超过</mtext><mn>1000</mn><mtext>个。</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{blue}{\\large (2)redis的集群主节点数量基本不可能超过1000个。}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.3em;"></span><span class="mopen sizing reset-size6 size7" style="color:blue;">(</span><span class="mord sizing reset-size6 size7" style="color:blue;">2</span><span class="mclose sizing reset-size6 size7" style="color:blue;">)</span><span class="mord mathnormal sizing reset-size6 size7" style="color:blue;">re</span><span class="mord mathnormal sizing reset-size6 size7" style="color:blue;">d</span><span class="mord mathnormal sizing reset-size6 size7" style="color:blue;">i</span><span class="mord mathnormal sizing reset-size6 size7" style="color:blue;">s</span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:blue;">的集群主节点数量基本不可能超过</span><span class="mord sizing reset-size6 size7" style="color:blue;">1000</span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:blue;">个。</span></span></span></span> 集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者不建议redis cluster节点数量超过1000个。那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="blue"><mstyle mathsize="1.2em"><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo><mtext>槽位越小，节点少的情况下，压缩比高，容易传输</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{blue}{\\large (3)槽位越小，节点少的情况下，压缩比高，容易传输}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.3em;"></span><span class="mopen sizing reset-size6 size7" style="color:blue;">(</span><span class="mord sizing reset-size6 size7" style="color:blue;">3</span><span class="mclose sizing reset-size6 size7" style="color:blue;">)</span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:blue;">槽位越小，节点少的情况下，压缩比高，容易传输</span></span></span></span> Redis主节点的配置信息中它所负责的哈希槽是通过一张bitmap的形式来保存的，在传输过程中会对bitmap进行压缩，但是如果bitmap的填充率slots /N很高的话(N表示节点数)， bitmap的压缩率就很低。如果节点数很少，而哈希槽数量很多的话，bitmap的压缩率就很低。</p><p>计算结论</p><p>Redis集群中内置了16384个哈希槽，redis会根据节点数量大致均等的将哈希槽映射到不同的节点。当需要在Redis集群中放置-一个key-value时， redis先对key使用crc16算法算出一个结果然后用结果对16384求余数[ CRC16(key) % 16384]， 这样每个key都会对应一个编号在0-16383之间的哈希槽，也就是映射到某个节点上。如下代码，key之A、B在Node2， key之C落在Node3上</p><p><img src="'+a+'" alt=""></p></li></ol><h3 id="redis集群不保证强一致性" tabindex="-1"><a class="header-anchor" href="#redis集群不保证强一致性"><span>Redis集群不保证强一致性</span></a></h3><p>redis集群<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="blue"><mstyle mathsize="1.2em"><mtext>不保证强一致性</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{blue}{\\large 不保证强一致性}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.82em;"></span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:blue;">不保证强一致性</span></span></span></span>，这意味着在特定的条件下，Redis集群可能会丢掉一些被系统收到的写入请求命令</p><p><img src="'+e+'" alt=""></p>',6)])])}const w=t(y,[["render",x]]),E=JSON.parse('{"path":"/article/xgni1ja5/","title":"3.slot槽位映射方案","lang":"zh-CN","frontmatter":{"title":"3.slot槽位映射方案","tags":["redis"],"createTime":"2025/08/25 22:29:43","permalink":"/article/xgni1ja5/","watermark":true},"readingTime":{"minutes":10.9,"words":3269},"git":{"createdTime":1756136329000,"updatedTime":1756136329000,"contributors":[{"name":"HRF","username":"HRF","email":"3398775460@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/HRF?v=4","url":"https://github.com/HRF"}]},"filePathRelative":"study-notes/back-end/redis/10.Redis集群(cluster)/3.slot槽位映射方案.md","headers":[],"categoryList":[{"id":"3c4c90","sort":10002,"name":"study-notes"},{"id":"fe643d","sort":10003,"name":"back-end"},{"id":"46b09b","sort":10033,"name":"redis"},{"id":"9fbdec","sort":10,"name":"Redis集群(cluster)"}]}');export{w as comp,E as data};
