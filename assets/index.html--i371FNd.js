import{_ as s,c as e,b as t,o as r}from"./app-BxaswAnj.js";const l="/rui-plume/assets/25.%E5%BF%83%E8%B7%B3-CF8uSgp_.png",m="/rui-plume/assets/26.%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%BB%B6%E8%BF%9F-DrRDrYor.png",n={};function o(i,a){return r(),e("div",null,[...a[0]||(a[0]=[t('<h1 id="复制原理和工作流程" tabindex="-1"><a class="header-anchor" href="#复制原理和工作流程"><span>复制原理和工作流程</span></a></h1><h3 id="slave启动-同步初请" tabindex="-1"><a class="header-anchor" href="#slave启动-同步初请"><span>slave启动，同步初请</span></a></h3><ul><li>slave启动成功链接到master后会发送一个sync命令</li><li>slave首次全新连接master，一次完全同步(全量复制)将被自动执行，slave自身原有数据会被master数据覆盖清除</li></ul><h3 id="首次连接-全量复制" tabindex="-1"><a class="header-anchor" href="#首次连接-全量复制"><span>首次连接，全量复制</span></a></h3><ul><li>master节点收到sync命令后会开始在后台保存快照(即RDB持久化，主从复制时会触发RDB)，同时收集所有接收到的用于修改数据集的命令并缓存起来，master节点执行RDB持久化完后，master将RDB快照文件和所有缓存的命令发送到所有slave，以完成一次完全同步</li><li>而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中，从而完成复制初始化</li></ul><h3 id="心跳持续-保持通信" tabindex="-1"><a class="header-anchor" href="#心跳持续-保持通信"><span>心跳持续，保持通信</span></a></h3><ul><li><p>repl-ping-replica-period 10</p><p><img src="'+l+'" alt=""></p></li></ul><h3 id="进入平稳-增量复制" tabindex="-1"><a class="header-anchor" href="#进入平稳-增量复制"><span>进入平稳，增量复制</span></a></h3><ul><li>master继续将新的所有收集到的修改命令自动依次传送给slave，完成同步</li></ul><h3 id="从机下线-重连续传" tabindex="-1"><a class="header-anchor" href="#从机下线-重连续传"><span>从机下线，重连续传</span></a></h3><ul><li>master会检查backlog里面的offset，master和slave都会保存一个复制的offset还有一个masterId，offset是保存在backlog中的。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mi>m</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>r</mi><mtext>只会把已经缓存的</mtext><mi>o</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><mi>t</mi><mtext>后面的数据复制给</mtext><mi>s</mi><mi>l</mi><mi>a</mi><mi>v</mi><mi>e</mi><mtext>，类似断点续传</mtext></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{red}{master只会把已经缓存的offset后面的数据复制给slave，类似断点续传}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="color:red;">ma</span><span class="mord mathnormal" style="color:red;">s</span><span class="mord mathnormal" style="color:red;">t</span><span class="mord mathnormal" style="margin-right:0.02778em;color:red;">er</span><span class="mord cjk_fallback" style="color:red;">只会把已经缓存的</span><span class="mord mathnormal" style="color:red;">o</span><span class="mord mathnormal" style="margin-right:0.10764em;color:red;">ff</span><span class="mord mathnormal" style="color:red;">se</span><span class="mord mathnormal" style="color:red;">t</span><span class="mord cjk_fallback" style="color:red;">后面的数据复制给</span><span class="mord mathnormal" style="color:red;">s</span><span class="mord mathnormal" style="margin-right:0.01968em;color:red;">l</span><span class="mord mathnormal" style="color:red;">a</span><span class="mord mathnormal" style="margin-right:0.03588em;color:red;">v</span><span class="mord mathnormal" style="color:red;">e</span><span class="mord cjk_fallback" style="color:red;">，类似断点续传</span></span></span></span></li></ul><h3 id="复制的缺点" tabindex="-1"><a class="header-anchor" href="#复制的缺点"><span>复制的缺点</span></a></h3><ul><li><p>复制延时，信号衰减</p><p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p><p><img src="'+m+'" alt=""></p></li><li><p>master挂了怎么办？</p><p>默认情况下，不会在slave节点中自动选一个master</p><p>那每次都要人工干预？ -&gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>无人值守变成刚需</mtext></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{red}{无人值守变成刚需}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback" style="color:red;">无人值守变成刚需</span></span></span></span></p></li></ul>',13)])])}const p=s(n,[["render",o]]),d=JSON.parse('{"path":"/article/ymxrt4ro/","title":"4.复制原理和工作流程","lang":"zh-CN","frontmatter":{"title":"4.复制原理和工作流程","createTime":"2025/08/25 22:29:42","permalink":"/article/ymxrt4ro/","watermark":true},"readingTime":{"minutes":1.67,"words":500},"git":{"createdTime":1756136329000,"updatedTime":1756136329000,"contributors":[{"name":"HRF","username":"HRF","email":"3398775460@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/HRF?v=4","url":"https://github.com/HRF"}]},"filePathRelative":"study-notes/back-end/redis/8.Redis复制(replica)/4.复制原理和工作流程.md","headers":[],"categoryList":[{"id":"3c4c90","sort":10002,"name":"study-notes"},{"id":"fe643d","sort":10003,"name":"back-end"},{"id":"46b09b","sort":10033,"name":"redis"},{"id":"add91c","sort":8,"name":"Redis复制(replica)"}]}');export{p as comp,d as data};
