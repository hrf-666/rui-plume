import{_ as e,c as a,b as i,o as t}from"./app-BxaswAnj.js";const n="/rui-plume/assets/6.Java%E8%BF%9E%E6%8E%A5Redis%E7%BB%8F%E5%85%B8%E6%95%85%E9%9A%9C-Dva63WdG.png",l="/rui-plume/assets/7.%E5%B0%86Lettuce%E4%BA%8C%E6%96%B9%E5%8C%85%E4%BB%B2%E8%A3%81%E6%8E%89-B273m8yh.png",r="/rui-plume/assets/8.%E5%88%B7%E6%96%B0%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4%E6%8B%93%E6%89%91%E5%8A%A8%E6%80%81%E6%84%9F%E5%BA%94%E5%AE%98%E7%BD%91%E8%AF%B4%E6%98%8E-DcHQvwUW.png",m={};function p(o,s){return t(),a("div",null,[...s[0]||(s[0]=[i(`<h1 id="redistemplate连接集群" tabindex="-1"><a class="header-anchor" href="#redistemplate连接集群"><span>RedisTemplate连接集群</span></a></h1><p>启动Redis集群6台实例</p><p>第一次改写YML</p><div class="language-yaml line-numbers-mode" data-highlighter="shiki" data-ext="yaml" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-yaml"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># ===========================redis集群===========================</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">spring.redis.password=123456</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 获取失败 最大重定向次数</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">spring.redis.cluster.max-redirects=3</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">spring.redis.lettuce.pool.max-active=8</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">spring.redis.1ettuce.pool.max-wait=-1ms</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">spring.redis.1ettuce.pool.max-idle=8</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">spring.redis.lettuce.pool.min-idle=0</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">spring.redis.cluster.nodes=192.168.111.175:6381,192.168.111.175:6382,192.168.111.176:6383,192.168.111.176:6384</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接通过微服务访问Redis集群</p><p>一切正常 （http://localhost:7777/swagger-ui.html）</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mstyle mathsize="1.2em"><mtext>问题来了</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{red}{\\large 问题来了}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.82em;"></span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:red;">问题来了</span></span></span></span></p><ol><li><p>人为模拟，master-6381机器意外宕机，手动shutdown</p></li><li><p>先对redis集群用命令的方式，手动验证各种读写命令，看看6384是否上位</p></li><li><p>Redis Cluster集群能自动感知并自动完成主备切换，对应的slave6384会被选举为新的master节点</p></li><li><p>通过redis客户端连接6384可以正常进行读写操作</p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="green"><mstyle mathsize="1.2em"><mtext>微服务客户端再次读写访问试试</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{green}{\\large 微服务客户端再次读写访问试试}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.82em;"></span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:green;">微服务客户端再次读写访问试试</span></span></span></span></p><p>故障现象</p><p>SpringBoot客户端没有动态感知RedisCluster的最新集群信息</p><p>金典故障</p><p>【故障演练】 Redis Cluster集群部署采用了3主3从拓扑结构，数据读写访问master节点，slave节点负责备份。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mstyle mathsize="1.2em"><mtext>当</mtext><mi>m</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>r</mi><mtext>宕机主从切换成功，</mtext><mi>r</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>s</mi><mtext>手动</mtext><mi>O</mi><mi>K</mi><mtext>，</mtext><mi>b</mi><mi>u</mi><mi>t</mi><mn>2</mn><mtext>个经典故障</mtext></mstyle></mstyle></mrow><annotation encoding="application/x-tex">\\textcolor{red}{\\large 当master宕机主从切换成功，redis手动OK，but 2个经典故障}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;"></span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:red;">当</span><span class="mord mathnormal sizing reset-size6 size7" style="color:red;">ma</span><span class="mord mathnormal sizing reset-size6 size7" style="color:red;">s</span><span class="mord mathnormal sizing reset-size6 size7" style="color:red;">t</span><span class="mord mathnormal sizing reset-size6 size7" style="margin-right:0.02778em;color:red;">er</span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:red;">宕机主从切换成功，</span><span class="mord mathnormal sizing reset-size6 size7" style="color:red;">re</span><span class="mord mathnormal sizing reset-size6 size7" style="color:red;">d</span><span class="mord mathnormal sizing reset-size6 size7" style="color:red;">i</span><span class="mord mathnormal sizing reset-size6 size7" style="color:red;">s</span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:red;">手动</span><span class="mord mathnormal sizing reset-size6 size7" style="margin-right:0.02778em;color:red;">O</span><span class="mord mathnormal sizing reset-size6 size7" style="margin-right:0.07153em;color:red;">K</span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:red;">，</span><span class="mord mathnormal sizing reset-size6 size7" style="color:red;">b</span><span class="mord mathnormal sizing reset-size6 size7" style="color:red;">u</span><span class="mord mathnormal sizing reset-size6 size7" style="color:red;">t</span><span class="mord sizing reset-size6 size7" style="color:red;">2</span><span class="mord cjk_fallback sizing reset-size6 size7" style="color:red;">个经典故障</span></span></span></span></p><p><img src="`+n+'" alt=""></p><p>导致原因 SpringBoot 2.X版本，Redis默认的连接池采用Lettuce，当Redis集群节点发生变化后，Letture默认是不会刷新节点拓扑</p><p>解决方案</p><ol><li><p>排除lettuce采用Jedis（不推荐）</p><p><img src="'+l+'" alt=""></p></li><li><p>重写连接工厂实例（极度不推荐）</p></li><li><p>刷新节点集群拓扑动态感应</p><p><img src="'+r+'" alt=""></p><p>解决方法：</p><p>调用 RedisClusterClient.reloadPartitions 后台基于时间间隔的周期刷新 后台基于持续的 <strong>断开</strong> 和 <strong>移动</strong>、<strong>重定向</strong> 的自适应更新</p></li></ol></li></ol>',8)])])}const c=e(m,[["render",p]]),h=JSON.parse('{"path":"/article/za98ya6m/","title":"RedisTemplate连接集群","lang":"zh-CN","frontmatter":{"title":"RedisTemplate连接集群","tags":["redis"],"createTime":"2025/08/25 22:29:43","permalink":"/article/za98ya6m/","watermark":true},"readingTime":{"minutes":1.55,"words":466},"git":{"createdTime":1756136329000,"updatedTime":1756136329000,"contributors":[{"name":"HRF","username":"HRF","email":"3398775460@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/HRF?v=4","url":"https://github.com/HRF"}]},"filePathRelative":"study-notes/back-end/redis/11.SpringBoot集成Redis/3.RedisTemplate连接集群.md","headers":[],"categoryList":[{"id":"3c4c90","sort":10002,"name":"study-notes"},{"id":"fe643d","sort":10003,"name":"back-end"},{"id":"46b09b","sort":10033,"name":"redis"},{"id":"4d3675","sort":11,"name":"SpringBoot集成Redis"}]}');export{c as comp,h as data};
