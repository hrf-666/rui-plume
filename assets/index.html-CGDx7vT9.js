import{_ as a,c as i,b as e,o as r}from"./app-BxaswAnj.js";const t="/rui-plume/assets/29.%E5%BC%80%E5%90%AFAOF-Szkm2so9.jpg",p="/rui-plume/assets/30.AOF%E9%BB%98%E8%AE%A4%E4%BF%9D%E5%AD%98%E7%AD%96%E7%95%A5-NBmcZUC0.jpg",n="/rui-plume/assets/31.AOF%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84(Redis6%E5%8F%8A%E4%BB%A5%E5%89%8D)-VAs4mh0c.jpg",l="/rui-plume/assets/32.AOF%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84(Redis7)-DOx2S3eO.jpg",o="/rui-plume/assets/33.Redis%E6%96%B0%E8%80%81%E7%89%88%E6%9C%AC%E5%8C%BA%E5%88%AB-D3PIzaw7.jpg",c="/rui-plume/assets/34.AOF%E6%96%87%E4%BB%B6%E5%90%8D%E7%A7%B0(Redis6%E5%8F%8A%E4%BB%A5%E5%89%8D)-zprmRpQs.jpg",d="/rui-plume/assets/35.AOF%E6%96%87%E4%BB%B6%E5%90%8D%E7%A7%B0(Redis7)-DDtSIOrb.jpg",A="/rui-plume/assets/36.redis7AOF%E9%85%8D%E7%BD%AE%E9%A1%B9-CQ70FQD2.jpg",m="/rui-plume/assets/37.aof%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6-BRD423Qw.jpg",E="/rui-plume/assets/38.aof%E6%96%87%E4%BB%B6%E5%BC%82%E5%B8%B8-oznkrGNm.jpg",B="/rui-plume/assets/39.aof%E5%BC%82%E5%B8%B8%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5-UsnSfP0f.jpg",h="/rui-plume/assets/40.aof%E6%96%87%E4%BB%B6%E4%BF%AE%E5%A4%8D-CAs15orY.jpg",F="/rui-plume/assets/41.AOF%E4%BC%98%E5%8A%BF-YrcCK4HI.png",u="/rui-plume/assets/42.AOF%E5%8A%A3%E5%8A%BF-Cp0za3JZ.png",f={};function O(g,s){return r(),i("div",null,[...s[0]||(s[0]=[e('<h1 id="aof案例演示和优劣对比" tabindex="-1"><a class="header-anchor" href="#aof案例演示和优劣对比"><span>AOF案例演示和优劣对比</span></a></h1><h3 id="配置文件说明-6-vs-7" tabindex="-1"><a class="header-anchor" href="#配置文件说明-6-vs-7"><span>配置文件说明 (6 VS 7)</span></a></h3><h4 id="如何开启aof" tabindex="-1"><a class="header-anchor" href="#如何开启aof"><span>如何开启aof</span></a></h4><p><img src="'+t+'" alt=""></p><h4 id="使用默认写回策略" tabindex="-1"><a class="header-anchor" href="#使用默认写回策略"><span>使用默认写回策略</span></a></h4><p><img src="'+p+'" alt=""></p><h4 id="aof文件-保存路径" tabindex="-1"><a class="header-anchor" href="#aof文件-保存路径"><span>aof文件-保存路径</span></a></h4><ul><li><p>redis6及以前</p><p>AOF保存文件的位置和RDB保存文件的位置一样，都是通过redis.conf配置文件的dir配置</p></li></ul><p><img src="'+n+'" alt=""></p><ul><li>redis7最新</li></ul><p><img src="'+l+'" alt=""></p><p><strong>一句话：</strong></p><p><img src="'+o+'" alt=""></p><h4 id="aof文件-保存名称" tabindex="-1"><a class="header-anchor" href="#aof文件-保存名称"><span>aof文件-保存名称</span></a></h4><ul><li>redis6及以前 ，有且仅有一个</li></ul><p><img src="'+c+'" alt=""></p><ul><li>Redis7 Multi Part AOF的设计</li></ul><p>从1个文件到3个文件</p><p><img src="'+d+'" alt=""></p><p><strong>MP-AOF实现</strong><strong>方案概述</strong> 顾名思义，MP-AOF就是将原来的单个AOF文件拆分成多个AOF文件。在MP-AOF中，我们将AOF分为三种类型, 分别为:</p><ul><li><p><strong>BASE: 表示基础AOF</strong>，它一般由子进程通过重写产生，该文件最多只有一个。</p></li><li><p><strong>INCR:表示增量AOF</strong>，它一般会在AOFRW开始执行时被创建，该文件可能存在多个。</p></li><li><p><strong>HISTORY</strong>:表示历史AOF，它由BASE和INCR AOF变化而来，每次AOFRW成功完成时，本次AOFRW之前对应的BASE和INCR AOF都将变为HISTORY，HISTORY类型的AOF会被Redis自动删除。</p></li></ul><p>为了管理这些AOF文件，我们引入了一个manifest (清单)文件来跟踪、管理这些AOF。同时，为了便于AOF备份和拷贝，我们将所有的AOF文件和manifest文件放入一个单独的文件目录中，目录名由appenddirname配置(Redis 7.0新增配置项)决定。</p><p>Redis7.0config 中对应的配置项</p><p><img src="'+A+'" alt=""></p><h3 id="正常恢复" tabindex="-1"><a class="header-anchor" href="#正常恢复"><span>正常恢复</span></a></h3><ol><li>修改默认的appendonly no，改为yes</li><li>写操作继续，生成aof文件到指定目录（然后将appendonly文件备份，使用flushdb+shutdown服务器来模拟redis宕机数据丢失，删除生成的新aof文件，将备份文件恢复） <img src="'+m+'" alt=""></li><li>恢复：重启redis然后重新加载，结果OK，将数据重新写入到了redis</li></ol><h3 id="异常恢复" tabindex="-1"><a class="header-anchor" href="#异常恢复"><span>异常恢复</span></a></h3><ol><li>故意胡乱改动正常的AOF文件，模拟网络闪断文件写入不完整等其他异常情况 <img src="'+E+'" alt=""></li><li>重启Redis之后就会进行AOF文件的载入 <img src="'+B+'" alt=""></li><li>异常修复命令：redis-check-aof --fix进行修复 <img src="'+h+'" alt=""></li><li>启动后OK</li></ol><h3 id="优势" tabindex="-1"><a class="header-anchor" href="#优势"><span>优势</span></a></h3><p>更好的保护数据不丢失、性能高、可做紧急恢复</p><p><img src="'+F+'" alt=""></p><ul><li>使用AOF Redis 更加持久: 您可以有不同的fsync 策略: 根本不fsync、每秒 fsync、每次查询时fsync。使用每秒fsync的默认策略，写入性能仍然很棒。fsync 是使用后台线程执行的，当没有fsync正在进行时，主线程将努力执行写入，因此您只能丢失一秒钟的写入。</li><li>AOF 日志是一个仅附加日志，因此不会出现寻道问题，也不会在断电时出现损坏问题。即使由于某种原因(磁盘已满或其他原因) 日志以写一半的命令结尾，redis-check-aof 工具也能够轻松修复它。</li><li>当AOF 变得太大时，Redis 能够在后台自动重写AOF。重写是完全安全的，因为当 Redis继续附加到旧文件时，会使用创建当前数据集所需的最少操作集生成一个全新的文件，一旦第二个文件准备就绪，Redis 就会切换两者并开始附加到新的那一个。</li><li>AOF以易于理解和解析的格式依次包含所有操作的日志。您甚至可以轻松导出AOF文件。例如，即使您不小心使用孩FLUSHALL命令刷新了所有内容，只要在此期间没有执行日志重写，您仍然可以通过停止服务器、删除最新命令并重新启动 Redis 来保存您的数据集。</li></ul><h3 id="劣势" tabindex="-1"><a class="header-anchor" href="#劣势"><span>劣势</span></a></h3><p>相同数据集的数据而言AOF文件要远大于RDB文件，恢复速度慢于RDB</p><p>AOF运行效率要慢于RDB，每秒同步策略效率较好，不同步效率和RDB相同</p><p><img src="'+u+'" alt=""></p><ul><li>AOF文件通常比相同数据集的等效 RDB 文件大。</li><li>根据确切的 fsync策略，AOF可能比 RDB 慢。一般来说，将fsync 设置为每秒性能仍然非常高，并且在禁用 fsync的情况下，即使在高负载下它也应该与 RDB 一样快。即使在巨大的写入负载的情况下，RDB仍然能够提供关于最大延迟的更多保证。</li></ul>',37)])])}const _=a(f,[["render",O]]),D=JSON.parse('{"path":"/article/rrigt7mu/","title":"7.AOF案例演示和优劣对比","lang":"zh-CN","frontmatter":{"title":"7.AOF案例演示和优劣对比","createTime":"2025/08/25 22:29:41","permalink":"/article/rrigt7mu/","watermark":true},"readingTime":{"minutes":4.01,"words":1202},"git":{"createdTime":1756136329000,"updatedTime":1756136329000,"contributors":[{"name":"HRF","username":"HRF","email":"3398775460@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/HRF?v=4","url":"https://github.com/HRF"}]},"filePathRelative":"study-notes/back-end/redis/4.Redis持久化/7.AOF案例演示和优劣对比.md","headers":[],"categoryList":[{"id":"3c4c90","sort":10002,"name":"study-notes"},{"id":"fe643d","sort":10003,"name":"back-end"},{"id":"46b09b","sort":10033,"name":"redis"},{"id":"3bae55","sort":4,"name":"Redis持久化"}]}');export{_ as comp,D as data};
